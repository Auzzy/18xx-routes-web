{% set col_width = board_layout["grid-size"]["col-width"] %}
{% set row_height = board_layout["grid-size"]["row-height"] %}

var legalCoords = {{ tile_coords | safe }};
var firstCoord = legalCoords[0];
var lastCoord = legalCoords[legalCoords.length - 1];
var currentCoordFocus = undefined;
var stopNames = {{ stop_names | safe }};
var routeColors = [
    "rgba(0, 255, 255, 0.8)",  // cyan
    "rgba(255, 178, 127, 1)",  // light tangelo
    "rgba(255, 0, 255, 0.8)",  // fuchsia
    "rgba(255, 0, 0, 0.8)",    // red
    "rgba(1, 1, 255, 0.8)",    // light medium blue
    "rgba(238, 232, 170, 1)"   // pale goldenrod
];
var terminiBoundaries = {{ termini_boundaries | safe }};

function areNeighbors(rowAndCol1, rowAndCol2) {
    {% if board_layout["space-orientation"] == "flat" %}
    return (rowAndCol1.col === rowAndCol2.col
            && (rowAndCol1.row + 2 === rowAndCol2.row || rowAndCol1.row - 2 === rowAndCol2.row))
        || (rowAndCol1.col + 1 === rowAndCol2.col
            && (rowAndCol1.row + 1 === rowAndCol2.row || rowAndCol1.row - 1 === rowAndCol2.row))
        || (rowAndCol1.col - 1 === rowAndCol2.col
            && (rowAndCol1.row + 1 === rowAndCol2.row || rowAndCol1.row - 1 === rowAndCol2.row));
    {% elif board_layout["space-orientation"] == "pointed" %}
    return (rowAndCol1.row === rowAndCol2.row
            && (rowAndCol1.col + 2 === rowAndCol2.col || rowAndCol1.col - 2 === rowAndCol2.col))
        || (rowAndCol1.row + 1 === rowAndCol2.row
            && (rowAndCol1.col + 1 === rowAndCol2.col || rowAndCol1.col - 1 === rowAndCol2.col))
        || (rowAndCol1.row - 1 === rowAndCol2.row
            && (rowAndCol1.col + 1 === rowAndCol2.col || rowAndCol1.col - 1 === rowAndCol2.col));
    {% endif %}
}

function drawRoutesOnMap(routes) {
    var routesCanvas = $("#routes-canvas").get(0);
    var context = routesCanvas.getContext('2d');

    $.get("{{ url_for('.cities') }}")
        .done(function(result) {
            for (var k = 0; k < routes.length; k++) {
                var coords = routes[k][1];

                var routeColor = routeColors[k % routeColors.length];

                var routeContext = routesCanvas.getContext("2d");
                routeContext.strokeStyle = routeColor;
                routeContext.shadowBlur = 10;
                routeContext.shadowColor = routeColor;
                routeContext.lineWidth = routesCanvas.width * 0.0071;

                routeContext.beginPath();

                var rowAndCol = coordToRowAndCol(coords[0]);
                var tileCenter = getTileCenter(routesCanvas, rowAndCol.row, rowAndCol.col);
                routeContext.moveTo(tileCenter.x, tileCenter.y);

                for (var index = 1; index < coords.length - 1; index++) {
                    var coordRowAndCol = coordToRowAndCol(coords[index]);
                    var enterCoordRowAndCol = coordToRowAndCol(coords[index - 1]);
                    var exitCoordRowAndCol = coordToRowAndCol(coords[index + 1]);

                    var coordTileCenter = getTileCenter(routesCanvas, coordRowAndCol.row, coordRowAndCol.col);
                    var exitCoordTileCenter = getTileCenter(routesCanvas, exitCoordRowAndCol.row, exitCoordRowAndCol.col);

                    var exitPoint = {x: (coordTileCenter.x + exitCoordTileCenter.x) / 2.0, y: (coordTileCenter.y + exitCoordTileCenter.y) / 2.0};

                    if (result["cities"].includes(coords[index]) && !result["split-cities"].includes(coords[index])) {
                        routeContext.lineTo(coordTileCenter.x, coordTileCenter.y);
                        routeContext.lineTo(exitPoint.x, exitPoint.y);
                    } else if (areNeighbors(enterCoordRowAndCol, exitCoordRowAndCol)) {
                        // Sharp curves
                        {% if board_layout["space-orientation"] == "flat" %}
                        routeContext.arcTo(coordTileCenter.x, coordTileCenter.y, exitPoint.x, exitPoint.y, (routesCanvas.height * {{ row_height + 0.006 }}) / 2);
                        {% elif board_layout["space-orientation"] == "pointed" %}
                        routeContext.arcTo(coordTileCenter.x, coordTileCenter.y, exitPoint.x, exitPoint.y, (routesCanvas.width * {{ col_width + 0.006 }}) / 2);
                        {% endif %}
                    } else {
                        // Shallow curves
                        {% if board_layout["space-orientation"] == "flat" %}
                        routeContext.arcTo(coordTileCenter.x, coordTileCenter.y, exitPoint.x, exitPoint.y, (3 * routesCanvas.height * {{ row_height + 0.007 }}) / 2);
                        {% elif board_layout["space-orientation"] == "pointed" %}
                        routeContext.arcTo(coordTileCenter.x, coordTileCenter.y, exitPoint.x, exitPoint.y, (3 * routesCanvas.width * {{ col_width + 0.007 }}) / 2);
                        {% endif %}
                    }
                }

                var finalRowAndCol = coordToRowAndCol(coords[coords.length - 1]);
                var finalTileCenter = getTileCenter(routesCanvas, finalRowAndCol.row, finalRowAndCol.col);
                routeContext.lineTo(finalTileCenter.x, finalTileCenter.y);

                routeContext.stroke();
            }
        })
        .fail(function(jqXHR, textStatus, errorThrown) {
            console.error(`Failed to draw routes on the map. There was an error while requesting the list of cities`);
            $("#calculate-error")
                .css("color", "red")
                .text("Failed to draw the route set on the map.");
        });
}

function clearAllHighlights() {
    var canvas = $("#tile-focus-canvas").get(0);
    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
}

function keepHighlightVisible(tilePoints) {
    var mapImg = $("#placed-tiles-board");

    var tileOrigin = {
        x: Math.min(...tilePoints.map(coord => coord.x)) + mapImg.offset().left,
        y: Math.min(...tilePoints.map(coord => coord.y)) + mapImg.offset().top
    }
    var tileAntiOrigin = {
        x: Math.max(...tilePoints.map(coord => coord.x)) + mapImg.offset().left,
        y: Math.max(...tilePoints.map(coord => coord.y)) + mapImg.offset().top
    };

    var viewportTop = $(window).scrollTop();
    var viewportBottom = viewportTop + window.innerHeight;
    var viewportLeft = $(window).scrollLeft();
    var viewportRight = viewportLeft + window.innerWidth;

    var scrollTop = viewportTop;
    var scrollLeft = viewportLeft;

    if (tileOrigin.y < viewportTop) {
        scrollTop = Math.max(mapImg.offset().top, viewportTop - ((viewportBottom - viewportTop) - (tileAntiOrigin.y - tileOrigin.y)));
    } else if (tileAntiOrigin.y > viewportBottom) {
        scrollTop = Math.min(mapImg.offset().top + mapImg.height(), viewportBottom - (tileAntiOrigin.y - tileOrigin.y));
    }

    if (tileOrigin.x < viewportLeft) {
        scrollLeft = Math.max(mapImg.offset().left, viewportLeft - ((viewportRight - viewportLeft) - (tileAntiOrigin.x - tileOrigin.x)));
    } else if (tileAntiOrigin.x > viewportRight) {
        scrollLeft = Math.min(mapImg.offset().left + mapImg.width(), viewportRight - (tileAntiOrigin.x - tileOrigin.x));
    }

    window.scrollTo({
        top: scrollTop,
        left: scrollLeft,
        behavior: 'smooth'
    });

}

function outlineCoord(coord, canvasId, outlineColor) {
    var mapImg = $("#placed-tiles-board").get(0);
    var outlineCanvas = $(canvasId).get(0);

    var rowAndCol = coordToRowAndCol(coord);
    var tilePoints = getTilePoints(outlineCanvas, rowAndCol.row, rowAndCol.col);

    var outlineContext = outlineCanvas.getContext("2d");

    // Store current context settings
    var strokeStyle = outlineContext.strokeStyle;
    var shadowBlur = outlineContext.shadowBlur;
    var shadowColor = outlineContext.shadowColor;
    var lineWidth = outlineContext.lineWidth;

    // Draw outline
    outlineContext.strokeStyle = outlineColor;
    outlineContext.shadowBlur = 20;
    outlineContext.shadowColor = outlineColor;
    outlineContext.lineWidth = 3;
    outlineContext.beginPath();
    outlineContext.moveTo(tilePoints[0].x, tilePoints[0].y);
    tilePoints.slice(1).forEach(point => outlineContext.lineTo(point.x, point.y));
    outlineContext.closePath();
    outlineContext.stroke();

    // Restore context settings
    outlineContext.strokeStyle = strokeStyle;
    outlineContext.shadowBlur = shadowBlur;
    outlineContext.shadowColor = shadowColor;
    outlineContext.lineWidth = lineWidth;

    return tilePoints;
}

function highlightSelectedCoord(coord) {
    var tilePoints = outlineCoord(coord, "#tile-focus-canvas", "#00ffff");
    keepHighlightVisible(tilePoints);
}

function drawMap() {
    var mapCanvas = $("#placed-tiles-board-canvas").get(0);
    mapCanvas.getContext('2d').clearRect(0, 0, mapCanvas.width, mapCanvas.height);

    getTilesAsTable().forEach(row => {
        drawTileOnMap(row[0], row[1], row[2]);
    });
}

function drawTileOnMap(coord, tileId, orientation) {
    function drawTile(context, tileImage, tileOrigin, tileCenter, mapImg, orientation) {
        context.save();
        context.translate(tileCenter.x, tileCenter.y);
        context.rotate(orientation * Math.PI / 3);
        context.translate(-tileCenter.x, -tileCenter.y);
        {% if board_layout["space-orientation"] == "flat" %}
        context.drawImage(tileImage, tileOrigin.x, tileOrigin.y, mapImg.width * {{ 4/3 * col_width }}, mapImg.height * {{ 2 * row_height }});
        {% elif board_layout["space-orientation"] == "pointed" %}
        context.drawImage(tileImage, tileOrigin.x, tileOrigin.y, mapImg.width * {{ 2 * col_width }}, mapImg.height * {{ 4/3 * row_height }});
        {% endif %}
        context.restore();
        context.rotate(0);
    }

    // Ensure we only draw if all 3 requirements are provided.
    if (isEmpty(coord) || isEmpty(tileId) || isEmpty(orientation)) {
        return;
    }

    var mapImg = $("#placed-tiles-board").get(0);
    var mapCanvas = $("#placed-tiles-board-canvas").get(0);
    var context = mapCanvas.getContext('2d');

    var rowAndCol = coordToRowAndCol(coord);
    var tileOrigin = getTileTopLeft(mapCanvas, rowAndCol.row, rowAndCol.col);

    // var orientationStr = orientation.toString();
    var tileIdStr = tileId.toString().padStart(3, "0");
    var imgSrc = `{{ url_for('static', filename='images/tiles') }}/${tileIdStr}-{{ board_layout["space-orientation"] }}.png`;

    var tileImage = new Image();
    tileImage.src = imgSrc;

    var tileCenter = getTileCenter(mapCanvas, rowAndCol.row, rowAndCol.col);

    // Draws the tile after it's loaded...
    $(tileImage).one("load", function() {
        drawTile(context, tileImage, tileOrigin, tileCenter, mapImg, orientation);
    });

    // ...as well as if it was already loaded
    drawTile(context, tileImage, tileOrigin, tileCenter, mapImg, orientation);
}

function removeTileFromMap(coord) {
    if (isEmpty(coord)) {
        return;
    }

    var mapImg = $("#placed-tiles-board").get(0);
    var mapCanvas = $("#placed-tiles-board-canvas").get(0);

    var rowAndCol = coordToRowAndCol(coord);
    var tilePoints = getTilePoints(mapCanvas, rowAndCol.row, rowAndCol.col);

    var mapContext = mapCanvas.getContext("2d");
    mapContext.globalCompositeOperation = 'destination-out';
    mapContext.beginPath();
    mapContext.moveTo(tilePoints[0].x, tilePoints[0].y);
    tilePoints.slice(1).forEach(point => mapContext.lineTo(point.x, point.y));
    mapContext.closePath();
    mapContext.fill();
    mapContext.globalCompositeOperation = 'source-over';
}

async function drawTokens() {
    var stationCanvas = $("#stations-canvas").get(0);
    stationCanvas.getContext('2d').clearRect(0, 0, stationCanvas.width, stationCanvas.height);

    var stationCountByCoord = {};
    getRailroadsAsTable().forEach(railroad => {
        if (!isEmpty(railroad[2])) {
            railroad[2].split(",").forEach(station => {
                [coord, branch] = station.trim().split(':');
                if (!(coord in stationCountByCoord)) {
                    stationCountByCoord[coord] = 0;
                }

                drawStationOnMap(coord, branch, stationCountByCoord[coord], railroad[0]);
                stationCountByCoord[coord]++;
            });
        }
    });

    getRemovedRailroads().forEach(railroad => {
        var coord = getRemovedRailroadsAsTable().find(row => row[0] === railroad)[1];
        if (!(coord in stationCountByCoord)) {
            stationCountByCoord[coord] = 0;
        }

        drawStationOnMap(coord, undefined, stationCountByCoord[coord], railroad);
        stationCountByCoord[coord]++;
    });

    await getPhase()
        .done(phase => {
            getPrivateCompaniesAsTable().forEach(company => {
                drawPrivateCompanyTokensHook(phase, company, stationCountByCoord);
            });
        });

    var canvas =  $("#station-overload-canvas").get(0);
    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
    Object.keys(stationCountByCoord).forEach(coord => {
        ifSpaceOverloaded(coord,
            () => {
                outlineCoord(coord, "#station-overload-canvas", "#ff0000");
            }
        );
    });
}

function drawPrivateCompanyOnMap(coord, privateCompanyName) {
    var stationCanvas = $("#stations-canvas").get(0);
    var stationContext = stationCanvas.getContext("2d");

    var rowAndCol = coordToRowAndCol(coord);
    var spacePoints = getTilePoints(stationCanvas, rowAndCol.row, rowAndCol.col);
    var spaceOrigin = getTileTopLeft(stationCanvas, rowAndCol.row, rowAndCol.col);
    var spaceSize = {
        width: Math.max(...spacePoints.map(coord => coord.x)) - Math.min(...spacePoints.map(coord => coord.x)),
        height: Math.max(...spacePoints.map(coord => coord.y)) - Math.min(...spacePoints.map(coord => coord.y))
    };

    var imgSrc = `{{ url_for('static', filename='images/tokens') }}/${privateCompanyName}.png`;

    var tokenImage = new Image();
    tokenImage.src = imgSrc;
    tokenImage.width = spaceSize.width * 0.20;
    tokenImage.height = spaceSize.height * 0.175;

    getPrivateCompanySpaceInfo(coord, privateCompanyName, (spaceInfo) => {
        // Draws the token after it's loaded...
        $(tokenImage).one("load", function() {
            drawPrivateCompany(stationContext, tokenImage, spaceOrigin, spaceInfo);
        });

        // ...as well as if it was already loaded
        drawPrivateCompany(stationContext, tokenImage, spaceOrigin, spaceInfo);
    });
}

function drawPrivateCompany(context, tokenImage, spaceOrigin, spaceInfo) {
    var offset = spaceInfo["offset"];

    var x = spaceOrigin.x + tokenImage.width * offset["x"] - tokenImage.width / 2;
    var y = spaceOrigin.y + tokenImage.height * offset["y"];

    context.drawImage(tokenImage, x, y, tokenImage.width, tokenImage.height);
}

function drawStationOnMap(coord, branch, stationCount, railroadName) {
    var stationCanvas = $("#stations-canvas").get(0);
    var stationContext = stationCanvas.getContext("2d");

    var rowAndCol = coordToRowAndCol(coord);
    var tilePoints = getTilePoints(stationCanvas, rowAndCol.row, rowAndCol.col);

    var tileCenter = getTileCenter(stationCanvas, rowAndCol.row, rowAndCol.col);
    var tileSize = {
        width: Math.max(...tilePoints.map(coord => coord.x)) - Math.min(...tilePoints.map(coord => coord.x)),
        height: Math.max(...tilePoints.map(coord => coord.y)) - Math.min(...tilePoints.map(coord => coord.y))
    };

    var imgSrc = `{{ url_for('static', filename='images/tokens') }}/${railroadName}.png`;

    var stationImage = new Image();
    stationImage.src = imgSrc;
    stationImage.width = tileSize.width * {% if board_layout["space-orientation"] == 'flat' %}0.255{% elif board_layout["space-orientation"] == 'pointed' %}0.295{% endif %};
    stationImage.height = tileSize.height * {% if board_layout["space-orientation"] == 'flat' %}0.295{% elif board_layout["space-orientation"] == 'pointed' %}0.255{% endif %};

    getTileInfo(coord, (tileInfo) => {
        // Draws the station after it's loaded...
        $(stationImage).one("load", function() {
            drawStation(stationContext, stationImage, tileCenter, stationCount, tileInfo, branch, stationCanvas);
        });

        // ...as well as if it was already loaded
        drawStation(stationContext, stationImage, tileCenter, stationCount, tileInfo, branch, stationCanvas);
    });
}

function drawStation(context, stationImage, tileCenter, stationCount, tileInfo, branch, mapImg) {
    var capacity = tileInfo["capacity"];
    var orientation = tileInfo["orientation"];
    var offset = tileInfo["offset"];
    var isSplitCity = tileInfo["is-split-city"];

    var x = 0;
    var y = 0;

    if (isSplitCity) {
        orientation = orientation || 0;

        // Use the offset to locate the stations on the tile/space, then
        // reflect the stations around the tile orientation * 60 degrees.
        var xOffset = -stationImage.width * offset[branch]["x"];
        var yOffset = -stationImage.height * offset[branch]["y"];

        var r = Math.sqrt(Math.pow(xOffset, 2) + Math.pow(yOffset, 2));
        var angle = Math.atan(yOffset / xOffset);
        // Adjustment for arctan
        if (xOffset < 0) {
            angle += Math.PI;
        }
        angle += orientation * Math.PI / 3;

        x = tileCenter.x - (stationImage.width / 2.0) - r * Math.cos(angle);
        y = tileCenter.y - (stationImage.height / 2.0) - r * Math.sin(angle);
    } else if (capacity === 1) {
        x = tileCenter.x - (stationImage.width / 2.0) + stationImage.width * offset["x"];
        y = tileCenter.y - (stationImage.height / 2.0) + stationImage.height * offset["y"];
    } else {
        var stationAdjustment = capacity === 2 ? Math.PI : 2 * Math.PI / 3;

        orientation = orientation || 0;
        var angle = 2 * Math.PI / 3 + (offset["rotation"] || 0)  + orientation * Math.PI / 3 + stationCount * stationAdjustment;
        var xOffset = (3 * stationImage.width / 4.0) * Math.cos(angle);
        var yOffset = (3 * stationImage.height / 4.0) * Math.sin(angle);

        x = tileCenter.x - (stationImage.width / 2.0) + xOffset;
        y = tileCenter.y - (stationImage.height / 2.0) + yOffset;
    }

    context.drawImage(stationImage, x, y, stationImage.width, stationImage.height);
}

function rowAndColToCoord(rowAndCol) {
    var rowStr = String.fromCharCode(rowAndCol.row + 65);
    // col is stored 0-indexed, so adding 1 brings it in line with the display numbers.
    var colStr = (rowAndCol.col + 1).toString();
    return `${rowStr}${colStr}`;
}

function coordToRowAndCol(coord) {
    return {
        row: coord.charCodeAt(0) - 65,
        // 0-index the column to ease calculation
        col: parseInt(coord.substring(1), 10) - 1
    };
}

function getHexPoints(origin, img) {
    {% if board_layout["space-orientation"] == "pointed" %}
    return [
        {x: origin.x, y: origin.y + img.height * {{ 1/3 * row_height}}},
        {x: origin.x + img.width * {{ col_width }}, y: origin.y},
        {x: origin.x + img.width * {{ 2 * col_width }}, y: origin.y + img.height * {{ 1/3 * row_height }}},
        {x: origin.x + img.width * {{ 2 * col_width }}, y: origin.y + img.height * {{ row_height }}},
        {x: origin.x + img.width * {{ col_width }}, y: origin.y + img.height * {{ 4/3 * row_height }}},
        {x: origin.x, y: origin.y + img.height * {{ row_height }}}
    ];
    {% elif board_layout["space-orientation"] == "flat" %}
    return [
        {x: origin.x, y: origin.y + img.height * {{ row_height }}},
        {x: origin.x + img.width * {{ 1/3 * col_width }}, y: origin.y},
        {x: origin.x + img.width * {{ col_width }}, y: origin.y},
        {x: origin.x + img.width * {{ 4/3 * col_width }}, y: origin.y + img.height * {{ row_height }}},
        {x: origin.x + img.width * {{ col_width }}, y: origin.y + img.height * {{ 2 * row_height }}},
        {x: origin.x + img.width * {{ 1/3 * col_width }}, y: origin.y + img.height * {{ 2 * row_height }}}
    ];
    {% else %}
    console.error("Unable to calculate hex locations.");
    {% endif %}
}

function getTileTopLeft(mapImage, row, col) {
    var startX = mapImage.width * {{ board_layout["corner"]["x"] }};
    var startY = mapImage.height * {{ board_layout["corner"]["y"] }};

    var xcoord = startX + col * (mapImage.width * {{ col_width }});
    var ycoord = startY + row * (mapImage.height * {{ row_height }});

    return {x: xcoord, y: ycoord};
}

function getTileCenter(mapImage, row, col) {
    var tilePoints = getTilePoints(mapImage, row, col);
    return {
        x: (Math.max(...tilePoints.map(coord => coord.x)) + Math.min(...tilePoints.map(coord => coord.x))) / 2,
        y: (Math.max(...tilePoints.map(coord => coord.y)) + Math.min(...tilePoints.map(coord => coord.y))) / 2
    };
}

function getTilePoints(mapImage, row, col) {
    var origin = getTileTopLeft(mapImage, row, col);
    return getHexPoints(origin, mapImage);
}

function mapPointToTile(img, point) {
    for (row = 0; row < {{ board_layout["max-row"] + 1 }}; row++) {
        var col = row % 2 == {{ board_layout["parity"] }} ? 1 : 0;
        for (; col < {{ board_layout["max-col"] + 1 }}; col += 2) {
            var tilePoints = getTilePoints(img, row, col);
            if (isPointInPoly(tilePoints, point)) {
                return {row: row, col: col};
            }
        }
    }
}

function populateTileSelectorPrivateCompanyDropdown(privateCompanyContent, coord) {
    var dropdownMenu = privateCompanyContent.find(".dropdown-menu");
    dropdownMenu.empty();

    var companyName = privateCompanyContent.attr("data-name");
    var companyRow = getPrivateCompaniesAsTable().find(row => row[0] === companyName);

    getRailroadsAsTable()
        .forEach(railroad => {
            if (companyRow[2] === coord && companyRow[1] === railroad[0]) {
                return;
            }

            dropdownMenu
                .append($("<a></a>")
                    .addClass("dropdown-item")
                    .attr("data-owner", railroad[0])
                    .attr("href", "#")
                    .text(railroad[0])
                    .click(function() {
                        var row = getPrivateCompanyRow(privateCompanyContent.attr("data-name"));
                        setPrivateCompanyOwner(row, $(this).attr("data-owner"))
                            .then(() => {
                                setPrivateCompanyTokenCoord(row, coord);
                                drawTokens();
                            });

                        tileSelectorPrivateCompaniesDisplayOwner(privateCompanyContent, true);

                        updateLocalStoragePrivateCompanies();
                    }));
        });
}

function tileSelectorPrivateCompaniesDisplayOwner(privateCompanyContent, isTokenHere) {
    privateCompanyContent.find("div[data-owner]").remove();

    var companyName = privateCompanyContent.attr("data-name");
    var ownerName = getPrivateCompaniesAsTable().find(row => row[0] === companyName)[1];
    if (isTokenHere && !isEmpty(ownerName)) {
        privateCompanyContent.find(".dropdown-toggle").text(`Change ${companyName} owner`);

        privateCompanyContent
            .append($("<div></div>")
                .css("margin-top", 10)
                .attr("data-owner", ownerName)
                .append($("<span></span>")
                    .css("font-weight", "bold")
                    .text("Owner"))
                .append($("<span></span>")
                    .css("margin-left", 5)
                    .text(ownerName))
                .append($("<button></button>")
                    .addClass("btn btn-sm btn-outline-danger")
                    .css("margin-left", 10)
                    .attr("type", "button")
                    .append($("<span></span>")
                        .addClass("oi oi-delete"))
                    .click(function() {
                        removePrivateCompany(`${companyName}`);
                        tileSelectorPrivateCompaniesDisplayOwner(privateCompanyContent, false);
                        drawTokens();
                    })));
    } else {
        privateCompanyContent.find(".dropdown-toggle").text(`Place ${companyName} token`);
    }
}

function populatePrivateCompanies(coord) {
    $("#tile-selector-private-companies-content").empty();

    getOpenPrivateCompanies()
        .done(result => {
            var tokenCoords = result["tokenCoords"];
            result["privateCompanies"]
                .filter(companyName => getOrDefault(tokenCoords, companyName, []).includes(coord))
                .forEach(companyName => {
                    var privateCompanyContent = $("<div></div>")
                        .attr("data-name", `${companyName}`)
                        .css("margin-bottom", 10)
                        .append($("<div></div>")
                            .addClass("dropdown")
                            .append($("<button></button>")
                                .addClass("btn btn-sm btn-outline-success dropdown-toggle")
                                .attr("type", "button")
                                .attr("data-toggle", "dropdown")
                                .attr("aria-haspopup", "true")
                                .attr("aria-expanded", "false")
                                .text(`Place ${companyName} token`))
                            .append($("<div></div>")
                                .addClass("dropdown-menu"))
                            .on("show.bs.dropdown", function() {
                                populateTileSelectorPrivateCompanyDropdown($(privateCompanyContent), coord);
                            }));

                    var companyRow = getPrivateCompaniesAsTable().find(row => row[0] === companyName);
                    var isTokenHere = !isEmpty(companyRow[2]) && companyRow[2] === coord;
                    tileSelectorPrivateCompaniesDisplayOwner($(privateCompanyContent), isTokenHere);

                    $("#tile-selector-private-companies-content").append(privateCompanyContent);
                });

            if ($("#tile-selector-private-companies-content").children().length === 0) {
                $("#tile-selector-private-companies").hide();
            } else {
                $("#tile-selector-private-companies").show();
            }
        })
        .fail(function(jqXHR, textStatus, errorThrown) {
            $("#tile-selector-private-companies-content")
                .append($("<div></div>")
                    .css("color", "red")
                    .text("Failed to load the privates at this space."));
        });;
}

function placeStationButton(parent, coord) {
    parent
        .append($("<span></span>")
            .addClass("dropdown")
            .append($("<button></button>")
                .addClass("btn btn-outline-success dropdown-toggle")
                .attr("type", "button")
                .attr("data-toggle", "dropdown")
                .attr("aria-haspopup", "true")
                .attr("aria-expanded", "false")
                .append($("<span></span>")
                    .addClass("oi oi-plus")))
            .append($("<div></div>")
                .addClass("dropdown-menu"))
            .on("show.bs.dropdown", function() {
                populateTileSelectorStationDropdown(parent, coord);
            }));
}

function tileModalStationEntry(coord, railroadName) {
    var stationEntry = $("<div></div>")
        .css("padding", "10px 0px")
        .append($("<img></img>")
            .attr("src", `{{ url_for('static', filename='images/tokens') }}/${railroadName}.png`)
            .attr("height", 25)
            .attr("width", 25)
            .css("margin-right", 5))
        .append($("<span></span>")
            .text(railroadName));

    var uneditableStations = getRailroadFixedStations(railroadName);
    if (!uneditableStations.includes(coord)) {
        stationEntry
            .append($("<button></button>")
                .addClass("btn btn-sm btn-outline-danger")
                .css("margin-left", 10)
                .attr("type", "button")
                .append($("<span></span>")
                    .addClass("oi oi-delete"))
                .click(function() {
                    removeRailroadStation(getRailroadRow(railroadName), coord);
                    populateStations(coord);
                    drawTokens();
                    setTileSelectorModalMessage(coord);
                    clearCalculateTab();

                    updateLocalStorageRailroads();
                }));
    }

    return stationEntry;
}

function populateStations(coord) {
    $("#tile-stations").empty();
    $("#add-tile-stations").empty();

    getPhase()
        .done(phase => {
            var cell = coord.split(':')[0];
            var railroadsAtCoord = getRailroadsAtCoord(cell, phase);

            $.get("{{ url_for('.cities') }}")
                .done(function(result) {
                    if (result["split-cities"].includes(cell)) {
                        $("#tile-selector-stations").show();

                        var tile = getTileAtCoord(cell);
                        var tileId = isEmpty(tile) ? null : tile[1];
                        var orientation = isEmpty(tile) ? null : tile[2];
                        $.get("{{ url_for('.split_city_stations') }}", {coord: cell, tileId: tileId, orientation: orientation})
                            .done(response => {
                                response["split-city-stations"].forEach(neighbor => {
                                    var railroad = getRailroadsAsTable().find(railroadEntry => railroadEntry[2].includes(`${cell}:${neighbor}`));
                                    var stationEntry = null;
                                    if (railroad === undefined) {
                                        stationEntry = $("<div></div>").css("padding", "10px 0px");
                                    } else {
                                        stationEntry = tileModalStationEntry(cell, railroad[0]);
                                    }

                                    $("#tile-stations").append(
                                        stationEntry
                                            .prepend($("<span></span>")
                                                .css("margin-right", 5)
                                                .css("font-weight", "bold")
                                                .css("font-size", "1.25em")
                                                .text(neighbor)));

                                    if (railroad === undefined) {
                                        placeStationButton(stationEntry, `${cell}:${neighbor}`);
                                    }
                                });
                            })
                            .fail(function(jqXHR, textStatus, errorThrown) {
                                console.error(`Failed to load the split city info for ${cell}.`);
                                $("#tile-stations")
                                    .css("color", "red")
                                    .text("Failed to load the city information for this tile.");
                            });
                    } else if (result["cities"].includes(cell)) {
                        getTileInfo(coord, function(tileInfo) {
                            if (tileInfo["phase"] !== 4 || tileInfo["capacity"] - tileInfo["home-to"].length >= 0) {
                                $("#tile-selector-stations").show();

                                Array.from(new Set(railroadsAtCoord)).forEach(railroad => {
                                    $("#tile-stations").append(tileModalStationEntry(cell, railroad[0]));
                                });

                                placeStationButton($("#add-tile-stations"), cell);
                            } else {
                                $("#tile-selector-stations").hide();
                            }
                        });
                    } else {
                        $("#tile-selector-stations").hide();
                    }
                })
                .fail(function(jqXHR, textStatus, errorThrown) {
                    console.error(`Failed to load the city info for ${cell}.`);
                    $("#tile-stations")
                        .css("color", "red")
                        .text("Failed to load the city information for this tile.");
                });
        })
        .fail(function(jqXHR, textStatus, errorThrown) {
            $("#tile-stations")
                .append($("<div></div>")
                    .css("color", "red")
                    .text("Failed to load the stations on this space."));
        });
}

function populateTileSelectorStationDropdown(sourceRow, coord) {
    var dropdownMenu = sourceRow.find(".dropdown-menu");
    dropdownMenu.empty();

    var cell = coord.split(':')[0];
    getRailroadsAsTable()
        .forEach(railroad => {
            if (railroad[2].split(",").map(stationCoord => stationCoord.split(':')[0]).includes(cell)) {
                return
            }

            dropdownMenu
                .append($("<a></a>")
                    .addClass("dropdown-item")
                    .attr("data-owner", railroad[0])
                    .attr("href", "#")
                    .text(railroad[0])
                    .click(function() {
                        var row = getRailroadRow(railroad[0]);
                        addRailroadStation(row, coord);
                        populateStations(coord);
                        drawTokens();
                        setTileSelectorModalMessage(coord);
                        clearCalculateTab();

                        updateLocalStorageRailroads();
                    }));
        });
}

function scrollTopHidden(parent, scrollItem, scrollOffset) {
    // Hack to get around scrollTop only working on visible elements.
    var origDisplay = parent.css("display");
    var origVisibility = parent.css("visibility");

    parent.css("visibility", "hidden");
    parent.css("display", "block");

    // Set scroll bar to the selected tile
    scrollItem.scrollTop(scrollOffset);

    // Reset hack
    parent.css("display", origDisplay);
    parent.css("visibility", origVisibility);
}

function setOpacity(element, alpha) {
    var alphaPercent = alpha * 100;
    return element
        .css("opacity", alpha.toString())
        // IE 8
        .css("-ms-filter", `progid:DXImageTransform.Microsoft.Alpha(Opacity=${alphaPercent})`)
        /* IE 7 */
        .css("filter", `alpha(opacity=${alphaPercent})`);
}

function populateOrientations(sourceTile, coord, tileId) {
    function highlightOrientation(source) {
        // Highlight the orientation as selected. This is both to preserve the old paradigm, and to
        // provide some visual cues if a bug occurs.
        $("#tile-orientations").children().each(function (k, element) {
            if (element != source) {
                setOpacity($(element), .2);
            }
        });

        setOpacity($(source), 1);

        $("#tile-orientations > .active").removeClass("active");
        $(source).addClass("active");
    }

    function selectOrientation(source) {
        highlightOrientation(source);

        // Commit the selection and close the modal
        var coord = $(source).attr("data-coord");
        var tileId = $(source).attr("data-tile-id");
        var orientation = $(source).attr("data-orientation");

        placeTile(coord, tileId, orientation);
        drawTileOnMap(coord, tileId, orientation);
        drawTokens();
        clearCalculateTab();

        $('#tile-selector').modal('hide');
    }

    var sourceOutline = $(sourceTile).css("outline");
    $("#tile-orientations").empty();
    $("#tile-errors").empty();

    return $.get("{{ url_for('.legal_orientations') }}", {coord: coord, tileId: tileId})
        .then(function(result) {
            // Reset the tile orientation viewport
            $("#tile-orientations").offset({"top": $("#tile-selector-tiles-content").offset().top});

            for (index in result["legal-orientations"]) {
                var orientation = result["legal-orientations"][index];
                var orientationStr = orientation.toString();
                var tileIdStr = tileId.toString().padStart(3, "0");
                var imgSrc = `{{ url_for('static', filename='images/tiles') }}/${tileIdStr}-{{ board_layout["space-orientation"] }}.png`;
                var rotateStr = `rotate(${orientation * 60}deg)`;

                // The img is wrapped in a div because I couldn't draw an outline on the img itself when it received
                // focus. I am unclear as to why. But I found that letting the div get focus and outlining the img
                // works. So sure.
                var tileImage = $("<div></div>")
                    .css("margin-bottom", "10px")
                    .css("position", "relative")
                    .css({
                        "-webkit-transform": rotateStr,
                        "-moz-transform": rotateStr,
                        "-ms-transform": rotateStr,
                        "-o-transform": rotateStr,
                        "transform": rotateStr
                    })
                    .attr("data-coord", coord)
                    .attr("data-tile-id", tileId)
                    .attr("data-orientation", orientation)
                    .attr("tabIndex", "-1")
                    .append($("<img></img>")
                        .attr("src", imgSrc)
                        .attr("width", "{% if board_layout['space-orientation'] == 'flat' %}100{% elif board_layout['space-orientation'] == 'pointed' %}88{% endif %}px")
                        .attr("height", "{% if board_layout['space-orientation'] == 'flat' %}88{% elif board_layout['space-orientation'] == 'pointed' %}100{% endif %}px")
                    )
                    .click(function(event) {
                        selectOrientation(this);
                    })
                    .keydown(function(event) {
                        if (event.key === "Enter") {
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();

                            selectOrientation(this);
                        } else if (event.key === "Tab") {
                            event.stopImmediatePropagation();
                            event.stopPropagation();
                            event.preventDefault();

                            var tileId = $(this).attr("data-tile-id");
                            var index = $(this).index();
                            if (event.shiftKey) {
                                if (index === 0) {
                                    $("#tile-options").find(`img[data-tile-id='${tileId}']`).prev().focus();
                                } else {
                                    $(this).prev().focus();
                                }
                            } else {
                                if (index === result["legal-orientations"].length - 1) {
                                    $("#tile-options").find(`img[data-tile-id='${tileId}']`).next().focus();
                                } else {
                                    $(this).next().focus();
                                }
                            }
                        }
                    })
                    .focus(function(event) {
                        $(this).children().css("outline", sourceOutline)
                    })
                    .blur(function(event) {
                        $(this).children().css("outline", "");
                    });
                
                $("#tile-orientations").append(setOpacity(tileImage, 1));
            }
        })
        .then(function() {
            var tileInfo = getTileAtCoord(coord);
            if (tileInfo !== null && tileInfo[1] === tileId) {
                highlightOrientation($(`#tile-orientations div[data-orientation='${tileInfo[2]}']`));
            }
        })
        .fail(function(jqXHR, textStatus, errorThrown) {
            console.error(`Failed to load the orientation options for ${coord}.`);
            scrollTopHidden($("#tile-selector"), $("#tile-selector-tiles-content"), 0);
            $("#tile-errors")
                .text("Failed to load the orientation options for this tile.");
        });
}

function populateTiles(coord) {
    function selectTile(source) {
        $("#tile-options").children().each(function (index, element) {
            if (element != source) {
                setOpacity($(element), .2);
            }
        });

        setOpacity($(source), 1);

        populateOrientations(source, $(source).attr("data-coord"), $(source).attr("data-tile-id"))
            .done(function() {
                $("#tile-orientations").children().first().focus();
                scrollTopHidden($("#tile-selector"), $("#tile-selector-tiles-content"), $(source).index() * 98);

                var orientationTileNum = $("#tile-orientations > .active").index();
                if (orientationTileNum !== -1) {
                    $("#tile-orientations")
                        .css("top", ($(source).index() - orientationTileNum) * 98);
                }
            });

        $("#tile-options > .active").removeClass("active");
        $(source).addClass("active");
    }

    $("#delete-tile-button").attr("data-coord", coord);
    $("#tile-options").empty();
    $("#tile-orientations").empty();
    $("#tile-errors").empty();

    $.get("{{ url_for('.legal_tiles') }}", {coord: coord})
        .then(function(result) {
            for (index in result["legal-tile-ids"]) {
                var tileId = result["legal-tile-ids"][index];
                var tileIdStr = tileId.toString().padStart(3, "0");
                var imgSrc = `{{ url_for('static', filename='images/tiles') }}/${tileIdStr}-{{ board_layout["space-orientation"] }}.png`;
            
                var tileImage = $("<img></img>")
                    .attr("src", imgSrc)
                    .attr("width", "{% if board_layout['space-orientation'] == 'flat' %}100{% elif board_layout['space-orientation'] == 'pointed' %}88{% endif %}px")
                    .attr("height", "{% if board_layout['space-orientation'] == 'flat' %}88{% elif board_layout['space-orientation'] == 'pointed' %}100{% endif %}px")
                    .attr("tabIndex", "0")
                    .css("display", "block")
                    .css("margin-bottom", "10px")
                    .attr("data-coord", coord)
                    .attr("data-tile-id", tileId)
                    .click(function() {
                        selectTile(this);
                    })
                    .keydown(function(event) {
                        if (event.key === "Enter") {
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();

                            selectTile(this);
                        } else if (event.key == "Tab") {
                            if ($(this).hasClass("active")) {
                                event.preventDefault();
                                event.stopPropagation();
                                event.stopImmediatePropagation();
                                if (event.shiftKey) {
                                    $("#tile-orientations").children().last().focus();
                                } else {
                                    $("#tile-orientations").children().first().focus();
                                }
                            }
                        }
                    });

                $("#tile-options").append(setOpacity(tileImage, 1));
            }

            if (result["legal-tile-ids"].length === 0) {
                $("#tile-selector-tiles").hide();
            } else {
                $("#tile-selector-tiles").show();
            }
        })
        .done(function() {
            var tileInfo = getTileAtCoord(coord);
            if (tileInfo !== null) {
                selectTile($(`#tile-options img[data-tile-id='${tileInfo[1]}']`));
            }
        })
        .fail(function(jqXHR, textStatus, errorThrown) {
            scrollTopHidden($("#tile-selector"), $("#tile-selector-tiles-content"), 0);
            console.error(`Failed to load the tile options for ${coord}.`);
            $("#tile-errors")
                .text("Failed to load the tile options for this tile.");
        });
}

function setTileSelectorModalHeader(coord) {
    if (stopNames.hasOwnProperty(coord)) {
        $("#tileSelectorLabel").text(stopNames[coord] + " (" + coord + ")");
    } else {
        $("#tileSelectorLabel").text(coord);
    }
}

function setTileSelectorModalMessage(coord) {
    ifSpaceOverloaded(coord,
        (capacity, stations, unclaimedReservations) => {
            if (stations.length > capacity) {
                var stationWord = stations.length === 1 ? "station" : "stations";
                $("#tile-selector-modal-message").text(`Contains ${stations.length} ${stationWord}, but capacity is ${capacity}.`);
            } else {
                $("#tile-selector-modal-message").text(`Not enough room for some reservations (${unclaimedReservations.join(", ")}).`);
            }
            updateTileSelectionViewport();
        },
        () => {
            $("#tile-selector-modal-message").empty();
            updateTileSelectionViewport();
        });
}

function keepOnScreen(viewport, content) {
    // Don't let the bottom of the tile orientation list pass the bottom of the modal viewport
    var viewportBottom = viewport.offset().top + viewport.height();
    var contentBottom = content.offset().top + content.height();
    if (viewportBottom > contentBottom) {
        content.offset({"top": viewportBottom - content.height()});
    }

    // Don't let the top of the tile orientation list pass the top of the modal viewport
    var viewportTop = viewport.offset().top;
    var contentTop = content.offset().top;
    if (viewportTop < contentTop) {
        content.offset({"top": viewportTop});
    }
}

$("#tile-selector-tiles-content").scroll(function(event) {
    keepOnScreen($("#tile-selector-tiles-content"), $("#tile-orientations"));
});

function getClickableTerminusCoord(pointOnImage) {
    var mapImage = $("#tile-focus-canvas").get(0);

    var terminusContext = mapImage.getContext("2d");
    terminusContext.strokeStyle = "rgba(0, 255, 255, 0.5)";
    terminusContext.lineWidth = 3;

    for (var name in terminiBoundaries) {
        var boundaryPoints = terminiBoundaries[name].map(data => {
            return {x: data.x * mapImage.width, y: data.y * mapImage.height}
        });

        if (isPointInPoly(boundaryPoints, pointOnImage)) {
            return Object.entries(stopNames).find(coordAndName => name === coordAndName[1])[0];
        }
    }

    return undefined;
}

function openTileSelectionModal(rowAndCol, pointOnImage) {
    $("#tile-errors").empty();

    var clickableTerminusCoord = getClickableTerminusCoord(pointOnImage);
    if (clickableTerminusCoord !== undefined) {
        getOpenPrivateCompanies()
            .done(result => {
                if (isEmpty(result["privateCompanies"].find(companyName => getOrDefault(result["tokenCoords"], companyName, []).includes(clickableTerminusCoord)))) {
                    return;
                }

                clearAllHighlights();
                setTileSelectorModalHeader(clickableTerminusCoord);
                setTileSelectorModalMessage(clickableTerminusCoord);
                populatePrivateCompanies(clickableTerminusCoord);

                $("#tile-selector-tiles").hide();
                $("#tile-selector-stations").hide();
                $("#tile-selector").modal("show");
            });
    } else if (rowAndCol !== undefined) {
        var coord = rowAndColToCoord(rowAndCol);
        if (legalCoords.includes(coord)) {
            clearAllHighlights();
            highlightSelectedCoord(coord);
            setTileSelectorModalHeader(coord);
            setTileSelectorModalMessage(coord);
            populateTiles(coord);
            populateStations(coord);
            populatePrivateCompanies(coord);

            // Ensure the modal always shows tiles when opened
            $("#tile-selector-tiles").click();
            $("#tile-selector").attr("data-coord", coord);
            $("#tile-selector").modal("show");
        }
    }
}

$("#tile-focus-canvas").click(canDisable(function(event) {
    var posXOnImg = event.pageX - $("#tile-focus-canvas").offset().left;
    var posYOnImg = event.pageY - $("#tile-focus-canvas").offset().top;

    var rowAndCol = mapPointToTile($("#tile-focus-canvas").get(0), {x: posXOnImg, y: posYOnImg});
    openTileSelectionModal(rowAndCol, {x: posXOnImg, y: posYOnImg});
}));

$("#delete-tile-button").click(function(event) {
    var coord = $(this).attr("data-coord");

    removeTile(coord);
    removeTileFromMap(coord);
    drawTokens();
    clearCalculateTab();
});

$("#tile-selector").on("show.bs.modal", function() {
    // Hack to get around scrollTop only working on visible elements.
    scrollTopHidden($("#tile-selector"), $("#tile-selector-tiles-content"), 0);
    keepOnScreen($("#tile-selector-tiles-content"), $("#tile-orientations"));
});

$("#tile-selector").on("shown.bs.modal", function() {
    keepOnScreen($("#tile-selector-tiles-content"), $("#tile-orientations"));
    $("#tile-selector-modal-body-tabs .nav-item a:visible").first().click();

    updateTileSelectionViewport();
});

function updateTileSelectionViewport() {
    // Resize tile selection window to exactly fix within the modal body viewport.
    var modalBody = $("#tile-selector-modal-body-tabs-content").parent();
    $("#tile-selector-tiles-content").height(
        // The height of the modal body viewport.
        modalBody.innerHeight()
        // The offset of the tile selector viewport, which is impacted by both the tab bar and the message section.
        - ($("#tile-selector-modal-body-tabs-content").offset().top - modalBody.offset().top));
}

$("#tile-selector").on("hidden.bs.modal", function() {
    currentCoordFocus = $('#tile-selector').attr("data-coord");
    $("#placed-tiles-board").focus();
});

$("#confirm-clear-map-modal-confirm").click(function() {
    tilesTable = [];
    updateLocalStoragePlacedTiles();
    drawMap();
    drawTokens();
    clearCalculateTab();
});

async function importTiles(importText) {
    var importTableData = [];
    await Promise.all(importText.trim().split("\n").map(rowStr => {
        var rowData = rowStr.split(";", 3).map(cell => cell.trim());

        return $.get("{{ url_for('.legal_orientations') }}", {coord: rowData[0], tileId: rowData[1]})
            .done(function(legalOrientationsResponse) {
                var legalOrientations = legalOrientationsResponse["legal-orientations"];
                var orientationTranslations = legalOrientationsResponse["translations"];
                var orientation = parseInt(rowData[2]);
                if (isEmpty(legalOrientations)) {
                    return;
                } else if (!legalOrientations.includes(orientation)) {
                    var translatedOrientation = orientationTranslations[orientation];
                    if (isEmpty(translatedOrientation)) {
                        return ;
                    }

                    rowData[2] = translatedOrientation.toString();
                }

                importTableData.push(rowData);
            })
            .catch(function(jqXHR, textStatus, errorThrown) {
                console.warn(`While importing tiles, failed to determine the legal tile orientations for ${rowData[0]}, which prevents collapsing duplicate orientations. Continuing...`);
            });
    }));

    var coordsInTable = [];
    tilesTable = [];
    importTableData.forEach(row => {
        if (coordsInTable.includes(row[0])) {
            return;
        }

        coordsInTable.push(row[0]);
        tilesTable.push(row.map(value => value.toString()));
    });

    return Promise.resolve();
}

function prepareTilesForExport(exportTilesTable) {
    exportTilesTable = exportTilesTable === undefined ? getTilesAsTable() : exportTilesTable;
    return exportTilesTable.sort((row1, row2) => row1[0].localeCompare(row2[0])).map(row => row.join("; ")).join("\n");
}

function toggleEnableMap(enable) {
    var disabled = enable ? "false" : "true";
    $("#tile-focus-canvas").attr("data-disabled", disabled);
    $("#placed-tiles-board").attr("data-disabled", disabled);
}

$("#placed-tiles-board").focus(canDisable(function(event) {
    if (currentCoordFocus === undefined) {
        // This condition only seems to be true if focus is coming from SHIFT+TAB, maybe because it's the final element
        // on the page. For now, that's good enough for me.
        currentCoordFocus = event.relatedTarget === null ? lastCoord : firstCoord;
    }

    clearAllHighlights();
    highlightSelectedCoord(currentCoordFocus);
}));

$("#placed-tiles-board").keydown(canDisable(function(event) {
    if (event.key === "Tab") {
        if (event.shiftKey) {
            if (currentCoordFocus === firstCoord) {
                currentCoordFocus = undefined;
            } else {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();

                currentCoordFocus = legalCoords[legalCoords.indexOf(currentCoordFocus) - 1];
            }
        } else {
            if (currentCoordFocus === lastCoord) {
                currentCoordFocus = undefined;
            } else {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();

                currentCoordFocus = legalCoords[legalCoords.indexOf(currentCoordFocus) + 1];
            }
        }

        clearAllHighlights();
        if (currentCoordFocus !== undefined) {
            highlightSelectedCoord(currentCoordFocus);
        }
    } else if (event.key === "Enter") {
        openTileSelectionModal(coordToRowAndCol(currentCoordFocus));
    } else if (["w", "a", "s", "d"].includes(event.key)) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();

        var rowAndCol = coordToRowAndCol(currentCoordFocus);
        {% if board_layout["space-orientation"] == "pointed" %}
        if (event.key === "w") {
            rowAndCol.row -= 1;
            rowAndCol.col += 1;
        } else if (event.key === "a") {
            rowAndCol.col -= 2;
        } else if (event.key === "s") {
            rowAndCol.row += 1;
            rowAndCol.col -= 1;
        } else if (event.key === "d") {
            rowAndCol.col += 2;
        }
        {% elif board_layout["space-orientation"] == "flat" %}
        if (event.key === "w") {
            rowAndCol.row -= 2;
        } else if (event.key === "a") {
            rowAndCol.row += 1;
            rowAndCol.col -= 1;
        } else if (event.key === "s") {
            rowAndCol.row += 2;
        } else if (event.key === "d") {
            rowAndCol.row -= 1;
            rowAndCol.col += 1;
        }
        {% endif %}

        var newCoord = rowAndColToCoord(rowAndCol);
        if (legalCoords.includes(newCoord)) {
            currentCoordFocus = newCoord;
            clearAllHighlights();
            highlightSelectedCoord(currentCoordFocus);
        }
    }
}));

$("#placed-tiles-board").blur(function() {
    currentCoordFocus = undefined;
});